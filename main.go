package main

import "fmt" // パッケージ名はすべて小文字でつける

func main() {
	fmt.Println("Hello, World!")

	// Goは型を名前の後ろに定義する。省略可能性が高いものほど後ろになる。
	// var num1 int = 123

	// 右辺で型が決まる場合は型名は不要
	// 関数外（パッケージレベル）でも利用できる
	// var num2 = 123

	// 変数宣言と代入を同時に行う短縮記法
	// ただし関数内部でのみ利用可能
	//num3 := 123

	// Goは宣言だけして未使用な変数がコードに残っているとエラーになるためコメントアウトしている。

	x := 1 // 関数ローカルな変数または引数で、宣言場所と利用場所が近く、説明がなくてもいいものは短く。1文字などの場合もあり。エラーを返す変数はerr。コンテキストはctx。
	if true {
		// コードブロックの内側で変数 x を再宣言できる
		// 外側の x には影響を及ぼさない
		x := 2         // シャドーイングされた値
		fmt.Println(x) // CamelCaseまたはcamelCaseとする。先頭が大文字なのでパッケージ外からも使えるパブリックな要素。なお先頭が小文字の場合はプライベートな要素である。
	}
	fmt.Println(x) // ここの位置では必ず1になる

	/* ポインター
	変数を作ってデータを格納すると、その変数はOSからもらったメモリのどこかに保存される。
	メモリにはアドレスがあります。そのアドレスを扱う機能がポインターである。
	Goのポインターは次のように使う。
	- 変数のポインター型には*（アスタリスク）を前置する
	- 既存の変数のポインターを取り出すには&を利用する
	*/
	var i int = 10 // ポインターの参照先となる普通の変数
	var p *int     // ポインターを格納する変数（デフォルトはnil）
	// fmt.Println(*p) // nilの参照先を取り出すと "panic: runtime error: invalid memory address or nil pointer dereference" が発生する
	p = &i // pにはiのアドレスが入る
	fmt.Println(p)
}
